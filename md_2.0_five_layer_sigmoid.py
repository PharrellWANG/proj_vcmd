# encoding: UTF-8import tensorflow as tffrom a_vcmd_read_data_multiple_test_set import read_data_setstf.set_random_seed(0)mode_decision = read_data_sets(reshape=False, validation_size=0)image_width = 16X = tf.placeholder(tf.float32, [None, image_width, image_width, 1])# correct answers go hereY_ = tf.placeholder(tf.float32, [None, 37])L = 250M = 220N = 180O = 150P = 100Q = 50# truncated normalW1 = tf.Variable(tf.truncated_normal([image_width ** 2, L], stddev=0.1))B1 = tf.Variable(tf.zeros([L]))W2 = tf.Variable(tf.truncated_normal([L, M], stddev=0.1))B2 = tf.Variable(tf.zeros([M]))W3 = tf.Variable(tf.truncated_normal([M, N], stddev=0.1))B3 = tf.Variable(tf.zeros([N]))W4 = tf.Variable(tf.truncated_normal([N, O], stddev=0.1))B4 = tf.Variable(tf.zeros([O]))W5 = tf.Variable(tf.truncated_normal([O, P], stddev=0.1))B5 = tf.Variable(tf.zeros([P]))W6 = tf.Variable(tf.truncated_normal([P, Q], stddev=0.1))B6 = tf.Variable(tf.zeros([Q]))W7 = tf.Variable(tf.truncated_normal([Q, 37], stddev=0.1))B7 = tf.Variable(tf.zeros([37]))XX = tf.reshape(X, [-1, image_width ** 2])# sigmoid, reluY1 = tf.nn.sigmoid(tf.matmul(XX, W1) + B1)Y2 = tf.nn.sigmoid(tf.matmul(Y1, W2) + B2)Y3 = tf.nn.sigmoid(tf.matmul(Y2, W3) + B3)Y4 = tf.nn.sigmoid(tf.matmul(Y3, W4) + B4)Y5 = tf.nn.sigmoid(tf.matmul(Y4, W5) + B5)Y6 = tf.nn.sigmoid(tf.matmul(Y5, W6) + B6)Y = tf.nn.softmax(tf.matmul(Y6, W7) + B7)cross_entropy = -tf.reduce_mean(Y_ * tf.log(Y)) * 1000.0  # normalized for batches of 100 images,# *10 because  "mean" included an unwanted division by 10correct_prediction = tf.equal(tf.argmax(Y, 1), tf.argmax(Y_, 1))accuracy = tf.reduce_mean(tf.cast(correct_prediction, tf.float32))learning_rate = 0.005# optimizer = tf.train.AdamOptimizer(0.005)optimizer = tf.train.GradientDescentOptimizer(learning_rate)train_step = optimizer.minimize(cross_entropy)init = tf.global_variables_initializer()saver = tf.train.Saver()# define the sessionsess = tf.Session()# run init operationsess.run(init)print("======------------>>>>>>>    " + str(mode_decision.train.images.shape[0]))# now after the init op, we can use the model now. (train the model)def training_step(i, update_train_data, update_test_data):    # load batch of images and correct answers    batch_X, batch_Y = mode_decision.train.next_batch(100)    sess.run(train_step, {X: batch_X, Y_: batch_Y})    # the backpropagation training step    # sess.run(train_step, {X: batch_X, Y_: batch_Y, lr: learning_rate})    if update_train_data:        a, c = sess.run([accuracy, cross_entropy], feed_dict={X: batch_X, Y_: batch_Y})        print(str(i) + ": accuracy:" + str(a) + " loss: " + str(c) + " (lr:" + str(learning_rate) + ")")    if update_test_data:        save_path = saver.save(sess, "/Users/Pharrell_WANG/PycharmProjects/proj_vcmd/checkpoint/a1_model.ckpt")        print("Model saved in file: %s" % save_path)        # test_data = {X: mode_decision.test.images, Y_: mode_decision.test.labels}        a, c = sess.run([accuracy, cross_entropy],                        feed_dict={X: mode_decision.test.images, Y_: mode_decision.test.labels})        print(str(i) + ": ********* epoch " + str(            i * 100 // mode_decision.train.images.shape[0] + 1) +              " ********* test accuracy for all:" + str(a) + " test loss: " + str(            c))        # test_data0 = {X: mode_decision.test0.images, Y_: mode_decision.test0.labels}        a, c = sess.run([accuracy, cross_entropy],                        feed_dict={X: mode_decision.test0.images, Y_: mode_decision.test0.labels})        print(str(i) + ": ********* epoch " + str(            i * 100 // mode_decision.train.images.shape[0] + 1) +              " ********* test accuracy for mode 0:" + str(a) + " test loss: " + str(            c))        a, c = sess.run([accuracy, cross_entropy],                        feed_dict={X: mode_decision.test1.images, Y_: mode_decision.test1.labels})        print(str(i) + ": ********* epoch " + str(            i * 100 // mode_decision.train.images.shape[0] + 1) +              " ********* test accuracy for mode 1:" + str(a) + " test loss: " + str(            c))        a, c = sess.run([accuracy, cross_entropy],                        feed_dict={X: mode_decision.test2.images, Y_: mode_decision.test2.labels})        print(str(i) + ": ********* epoch " + str(            i * 100 // mode_decision.train.images.shape[0] + 1) +              " ********* test accuracy for mode 2:" + str(a) + " test loss: " + str(            c))        a, c = sess.run([accuracy, cross_entropy],                        feed_dict={X: mode_decision.test24.images, Y_: mode_decision.test24.labels})        print(str(i) + ": ********* epoch " + str(            i * 100 // mode_decision.train.images.shape[0] + 1) +              " ********* test accuracy for mode 24:" + str(a) + " test loss: " + str(            c))        a, c = sess.run([accuracy, cross_entropy],                        feed_dict={X: mode_decision.test25.images, Y_: mode_decision.test25.labels})        print(str(i) + ": ********* epoch " + str(            i * 100 // mode_decision.train.images.shape[0] + 1) +              " ********* test accuracy for mode 25:" + str(a) + " test loss: " + str(            c))        # ----        a, c = sess.run([accuracy, cross_entropy],                        feed_dict={X: mode_decision.test26.images, Y_: mode_decision.test26.labels})        print(str(i) + ": ********* epoch " + str(            i * 100 // mode_decision.train.images.shape[0] + 1) +              " ********* test accuracy for mode 26:" + str(a) + " test loss: " + str(            c))        a, c = sess.run([accuracy, cross_entropy],                        feed_dict={X: mode_decision.test27.images, Y_: mode_decision.test27.labels})        print(str(i) + ": ********* epoch " + str(            i * 100 // mode_decision.train.images.shape[0] + 1) +              " ********* test accuracy for mode 27:" + str(a) + " test loss: " + str(            c))        a, c = sess.run([accuracy, cross_entropy],                        feed_dict={X: mode_decision.test28.images, Y_: mode_decision.test28.labels})        print(str(i) + ": ********* epoch " + str(            i * 100 // mode_decision.train.images.shape[0] + 1) +              " ********* test accuracy for mode 28:" + str(a) + " test loss: " + str(            c))        a, c = sess.run([accuracy, cross_entropy],                        feed_dict={X: mode_decision.test29.images, Y_: mode_decision.test29.labels})        print(str(i) + ": ********* epoch " + str(            i * 100 // mode_decision.train.images.shape[0] + 1) +              " ********* test accuracy for mode 29:" + str(a) + " test loss: " + str(            c))        a, c = sess.run([accuracy, cross_entropy],                        feed_dict={X: mode_decision.test30.images, Y_: mode_decision.test30.labels})        print(str(i) + ": ********* epoch " + str(            i * 100 // mode_decision.train.images.shape[0] + 1) +              " ********* test accuracy for mode 30:" + str(a) + " test loss: " + str(            c))        a, c = sess.run([accuracy, cross_entropy],                        feed_dict={X: mode_decision.test31.images, Y_: mode_decision.test31.labels})        print(str(i) + ": ********* epoch " + str(            i * 100 // mode_decision.train.images.shape[0] + 1) +              " ********* test accuracy for mode 31:" + str(a) + " test loss: " + str(            c))        a, c = sess.run([accuracy, cross_entropy],                        feed_dict={X: mode_decision.test32.images, Y_: mode_decision.test32.labels})        print(str(i) + ": ********* epoch " + str(            i * 100 // mode_decision.train.images.shape[0] + 1) +              " ********* test accuracy for mode 32:" + str(a) + " test loss: " + str(            c))        a, c = sess.run([accuracy, cross_entropy],                        feed_dict={X: mode_decision.test33.images, Y_: mode_decision.test33.labels})        print(str(i) + ": ********* epoch " + str(            i * 100 // mode_decision.train.images.shape[0] + 1) +              " ********* test accuracy for mode 33:" + str(a) + " test loss: " + str(            c))        a, c = sess.run([accuracy, cross_entropy],                        feed_dict={X: mode_decision.test34.images, Y_: mode_decision.test34.labels})        print(str(i) + ": ********* epoch " + str(            i * 100 // mode_decision.train.images.shape[0] + 1) +              " ********* test accuracy for mode 34:" + str(a) + " test loss: " + str(            c))        a, c = sess.run([accuracy, cross_entropy],                        feed_dict={X: mode_decision.test35.images, Y_: mode_decision.test35.labels})        print(str(i) + ": ********* epoch " + str(            i * 100 // mode_decision.train.images.shape[0] + 1) +              " ********* test accuracy for mode 35:" + str(a) + " test loss: " + str(            c))        a, c = sess.run([accuracy, cross_entropy],                        feed_dict={X: mode_decision.test36.images, Y_: mode_decision.test36.labels})        print(str(i) + ": ********* epoch " + str(            i * 100 // mode_decision.train.images.shape[0] + 1) +              " ********* test accuracy for mode 36:" + str(a) + " test loss: " + str(            c))for i in range(100000000 + 1):    training_step(i, i % 10 == 0, i % 500 == 0)