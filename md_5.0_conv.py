# encoding: UTF-8import tensorflow as tfimport mathfrom a_vcmd_read_data_multiple_test_set import read_data_setstf.set_random_seed(0)mode_decision = read_data_sets(reshape=False, validation_size=0)image_width = 16X = tf.placeholder(tf.float32, [None, image_width, image_width, 1])lr = tf.placeholder(tf.float32)pkeep = tf.placeholder(tf.float32)# correct answers go hereY_ = tf.placeholder(tf.float32, [None, 37])CONV_K = 60CONV_L = 120CONV_M = 240L = 1000M = 800N = 600O = 300P = 150Q = 60# 5x5 patch, 1 input channel, conv_K output channelsCONV_W1 = tf.Variable(tf.truncated_normal([5, 5, 1, CONV_K], stddev=0.1))CONV_B1 = tf.Variable(tf.constant(0.1, tf.float32, [CONV_K]))CONV_W2 = tf.Variable(tf.truncated_normal([3, 3, CONV_K, CONV_L], stddev=0.1))CONV_B2 = tf.Variable(tf.constant(0.1, tf.float32, [CONV_L]))CONV_W3 = tf.Variable(tf.truncated_normal([3, 3, CONV_L, CONV_M], stddev=0.1))CONV_B3 = tf.Variable(tf.constant(0.1, tf.float32, [CONV_M]))# truncated normalW1 = tf.Variable(tf.truncated_normal([4 * 4 * CONV_M, L], stddev=0.1))B1 = tf.Variable(tf.zeros([L]))W2 = tf.Variable(tf.truncated_normal([L, M], stddev=0.1))B2 = tf.Variable(tf.zeros([M]))W3 = tf.Variable(tf.truncated_normal([M, N], stddev=0.1))B3 = tf.Variable(tf.zeros([N]))W4 = tf.Variable(tf.truncated_normal([N, O], stddev=0.1))B4 = tf.Variable(tf.zeros([O]))W5 = tf.Variable(tf.truncated_normal([O, P], stddev=0.1))B5 = tf.Variable(tf.zeros([P]))W6 = tf.Variable(tf.truncated_normal([P, Q], stddev=0.1))B6 = tf.Variable(tf.zeros([Q]))W7 = tf.Variable(tf.truncated_normal([Q, 37], stddev=0.1))B7 = tf.Variable(tf.zeros([37]))# The modelstride = 1  # output is 16x16CONV_Y1 = tf.nn.relu(tf.nn.conv2d(X, CONV_W1, strides=[1, stride, stride, 1], padding='SAME') + CONV_B1)stride = 2  # output is 8x8CONV_Y2 = tf.nn.relu(tf.nn.conv2d(CONV_Y1, CONV_W2, strides=[1, stride, stride, 1], padding='SAME') + CONV_B2)stride = 2  # output is 4x4CONV_Y3 = tf.nn.relu(tf.nn.conv2d(CONV_Y2, CONV_W3, strides=[1, stride, stride, 1], padding='SAME') + CONV_B3)# reshape the output from the third convolution for the fully connected layerYY = tf.reshape(CONV_Y3, shape=[-1, 4 * 4 * CONV_M])# XX = tf.reshape(X, [-1, image_width ** 2])# relu, reluY1 = tf.nn.relu(tf.matmul(YY, W1) + B1)Y1d = tf.nn.dropout(Y1, pkeep)Y2 = tf.nn.relu(tf.matmul(Y1d, W2) + B2)Y2d = tf.nn.dropout(Y2, pkeep)Y3 = tf.nn.relu(tf.matmul(Y2d, W3) + B3)Y3d = tf.nn.dropout(Y3, pkeep)Y4 = tf.nn.relu(tf.matmul(Y3d, W4) + B4)Y4d = tf.nn.dropout(Y4, pkeep)Y5 = tf.nn.relu(tf.matmul(Y4d, W5) + B5)Y5d = tf.nn.dropout(Y5, pkeep)Y6 = tf.nn.relu(tf.matmul(Y5d, W6) + B6)Y6d = tf.nn.dropout(Y6, pkeep)# Y = tf.nn.softmax(tf.matmul(Y6, W7) + B7)Ylogits = tf.matmul(Y6d, W7) + B7Y = tf.nn.softmax(Ylogits)# cross_entropy = -tf.reduce_mean(Y_ * tf.log(Y)) * 1000.0  # normalized for batches of 100 images,# *10 because  "mean" included an unwanted division by 10cross_entropy = tf.nn.softmax_cross_entropy_with_logits(logits=Ylogits, labels=Y_)cross_entropy = tf.reduce_mean(cross_entropy) * 100correct_prediction = tf.equal(tf.argmax(Y, 1), tf.argmax(Y_, 1))accuracy = tf.reduce_mean(tf.cast(correct_prediction, tf.float32))# learning_rate = 0.005# optimizer = tf.train.AdamOptimizer(0.005)optimizer = tf.train.AdamOptimizer(lr)train_step = optimizer.minimize(cross_entropy)init = tf.global_variables_initializer()saver = tf.train.Saver()# define the sessionsess = tf.Session()# run init operationsess.run(init)print("======------------>>>>>>>    " + str(mode_decision.train.images.shape[0]))# now after the init op, we can use the model now. (train the model)def training_step(i, update_train_data, update_test_data):    # load batch of images and correct answers    batch_X, batch_Y = mode_decision.train.next_batch(100)    lrmax = 0.005    lrmin = 0.0001    decay_speed = 2000.0    learning_rate = lrmin + (lrmax - lrmin) * math.exp(-i / decay_speed)    sess.run(train_step, {X: batch_X, Y_: batch_Y, lr: learning_rate, pkeep: 0.75})    # the backpropagation training step    # sess.run(train_step, {X: batch_X, Y_: batch_Y, lr: learning_rate})    if update_train_data:        a, c = sess.run([accuracy, cross_entropy], feed_dict={X: batch_X, Y_: batch_Y, lr: learning_rate, pkeep: 1.0})        print(str(i) + ": accuracy:" + str(a) + " loss: " + str(c) + " (lr:" + str(learning_rate) + ")")    if update_test_data:        save_path = saver.save(sess,                               "/Users/Pharrell_WANG/PycharmProjects/proj_vcmd/checkpoint/md_5_conv_dropout_model.ckpt")        print("Model saved in file: %s" % save_path)        # test_data = {X: mode_decision.test.images, Y_: mode_decision.test.labels}        a, c = sess.run([accuracy, cross_entropy],                        feed_dict={X: mode_decision.test.images, Y_: mode_decision.test.labels, pkeep: 1.0})        print(str(i) + ": ********* epoch " + str(            i * 100 // mode_decision.train.images.shape[0] + 1) +              " ********* test accuracy for all:" + str(a) + " test loss: " + str(            c))        # test_data0 = {X: mode_decision.test0.images, Y_: mode_decision.test0.labels}        a, c = sess.run([accuracy, cross_entropy],                        feed_dict={X: mode_decision.test0.images, Y_: mode_decision.test0.labels, pkeep: 1.0})        print(str(i) + ": ********* epoch " + str(            i * 100 // mode_decision.train.images.shape[0] + 1) +              " ********* test accuracy for mode 0:" + str(a) + " test loss: " + str(            c))        a, c = sess.run([accuracy, cross_entropy],                        feed_dict={X: mode_decision.test1.images, Y_: mode_decision.test1.labels, pkeep: 1.0})        print(str(i) + ": ********* epoch " + str(            i * 100 // mode_decision.train.images.shape[0] + 1) +              " ********* test accuracy for mode 1:" + str(a) + " test loss: " + str(            c))        a, c = sess.run([accuracy, cross_entropy],                        feed_dict={X: mode_decision.test2.images, Y_: mode_decision.test2.labels, pkeep: 1.0})        print(str(i) + ": ********* epoch " + str(            i * 100 // mode_decision.train.images.shape[0] + 1) +              " ********* test accuracy for mode 2:" + str(a) + " test loss: " + str(            c))        a, c = sess.run([accuracy, cross_entropy],                        feed_dict={X: mode_decision.test24.images, Y_: mode_decision.test24.labels, pkeep: 1.0})        print(str(i) + ": ********* epoch " + str(            i * 100 // mode_decision.train.images.shape[0] + 1) +              " ********* test accuracy for mode 24:" + str(a) + " test loss: " + str(            c))        a, c = sess.run([accuracy, cross_entropy],                        feed_dict={X: mode_decision.test25.images, Y_: mode_decision.test25.labels, pkeep: 1.0})        print(str(i) + ": ********* epoch " + str(            i * 100 // mode_decision.train.images.shape[0] + 1) +              " ********* test accuracy for mode 25:" + str(a) + " test loss: " + str(            c))        # ----        a, c = sess.run([accuracy, cross_entropy],                        feed_dict={X: mode_decision.test26.images, Y_: mode_decision.test26.labels, pkeep: 1.0})        print(str(i) + ": ********* epoch " + str(            i * 100 // mode_decision.train.images.shape[0] + 1) +              " ********* test accuracy for mode 26:" + str(a) + " test loss: " + str(            c))        a, c = sess.run([accuracy, cross_entropy],                        feed_dict={X: mode_decision.test27.images, Y_: mode_decision.test27.labels, pkeep: 1.0})        print(str(i) + ": ********* epoch " + str(            i * 100 // mode_decision.train.images.shape[0] + 1) +              " ********* test accuracy for mode 27:" + str(a) + " test loss: " + str(            c))        a, c = sess.run([accuracy, cross_entropy],                        feed_dict={X: mode_decision.test28.images, Y_: mode_decision.test28.labels, pkeep: 1.0})        print(str(i) + ": ********* epoch " + str(            i * 100 // mode_decision.train.images.shape[0] + 1) +              " ********* test accuracy for mode 28:" + str(a) + " test loss: " + str(            c))        a, c = sess.run([accuracy, cross_entropy],                        feed_dict={X: mode_decision.test29.images, Y_: mode_decision.test29.labels, pkeep: 1.0})        print(str(i) + ": ********* epoch " + str(            i * 100 // mode_decision.train.images.shape[0] + 1) +              " ********* test accuracy for mode 29:" + str(a) + " test loss: " + str(            c))        a, c = sess.run([accuracy, cross_entropy],                        feed_dict={X: mode_decision.test30.images, Y_: mode_decision.test30.labels, pkeep: 1.0})        print(str(i) + ": ********* epoch " + str(            i * 100 // mode_decision.train.images.shape[0] + 1) +              " ********* test accuracy for mode 30:" + str(a) + " test loss: " + str(            c))        a, c = sess.run([accuracy, cross_entropy],                        feed_dict={X: mode_decision.test31.images, Y_: mode_decision.test31.labels, pkeep: 1.0})        print(str(i) + ": ********* epoch " + str(            i * 100 // mode_decision.train.images.shape[0] + 1) +              " ********* test accuracy for mode 31:" + str(a) + " test loss: " + str(            c))        a, c = sess.run([accuracy, cross_entropy],                        feed_dict={X: mode_decision.test32.images, Y_: mode_decision.test32.labels, pkeep: 1.0})        print(str(i) + ": ********* epoch " + str(            i * 100 // mode_decision.train.images.shape[0] + 1) +              " ********* test accuracy for mode 32:" + str(a) + " test loss: " + str(            c))        a, c = sess.run([accuracy, cross_entropy],                        feed_dict={X: mode_decision.test33.images, Y_: mode_decision.test33.labels, pkeep: 1.0})        print(str(i) + ": ********* epoch " + str(            i * 100 // mode_decision.train.images.shape[0] + 1) +              " ********* test accuracy for mode 33:" + str(a) + " test loss: " + str(            c))        a, c = sess.run([accuracy, cross_entropy],                        feed_dict={X: mode_decision.test34.images, Y_: mode_decision.test34.labels, pkeep: 1.0})        print(str(i) + ": ********* epoch " + str(            i * 100 // mode_decision.train.images.shape[0] + 1) +              " ********* test accuracy for mode 34:" + str(a) + " test loss: " + str(            c))        a, c = sess.run([accuracy, cross_entropy],                        feed_dict={X: mode_decision.test35.images, Y_: mode_decision.test35.labels, pkeep: 1.0})        print(str(i) + ": ********* epoch " + str(            i * 100 // mode_decision.train.images.shape[0] + 1) +              " ********* test accuracy for mode 35:" + str(a) + " test loss: " + str(            c))        a, c = sess.run([accuracy, cross_entropy],                        feed_dict={X: mode_decision.test36.images, Y_: mode_decision.test36.labels, pkeep: 1.0})        print(str(i) + ": ********* epoch " + str(            i * 100 // mode_decision.train.images.shape[0] + 1) +              " ********* test accuracy for mode 36:" + str(a) + " test loss: " + str(            c))for i in range(100000000 + 1):    training_step(i, i % 10 == 0, i % 500 == 0)